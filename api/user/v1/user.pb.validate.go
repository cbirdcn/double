// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/user/v1/user.proto

package user_v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AccountDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccountDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccountDetailMultiError, or
// nil if none found.
func (m *AccountDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AccountName

	// no validation rules for CreatedAt

	// no validation rules for Status

	if len(errors) > 0 {
		return AccountDetailMultiError(errors)
	}
	return nil
}

// AccountDetailMultiError is an error wrapping multiple validation errors
// returned by AccountDetail.ValidateAll() if the designated constraints
// aren't met.
type AccountDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountDetailMultiError) AllErrors() []error { return m }

// AccountDetailValidationError is the validation error returned by
// AccountDetail.Validate if the designated constraints aren't met.
type AccountDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountDetailValidationError) ErrorName() string { return "AccountDetailValidationError" }

// Error satisfies the builtin error interface
func (e AccountDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountDetailValidationError{}

// Validate checks the field values on CreateAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAccountRequestMultiError, or nil if none found.
func (m *CreateAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountName

	// no validation rules for Password

	if len(errors) > 0 {
		return CreateAccountRequestMultiError(errors)
	}
	return nil
}

// CreateAccountRequestMultiError is an error wrapping multiple validation
// errors returned by CreateAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAccountRequestMultiError) AllErrors() []error { return m }

// CreateAccountRequestValidationError is the validation error returned by
// CreateAccountRequest.Validate if the designated constraints aren't met.
type CreateAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAccountRequestValidationError) ErrorName() string {
	return "CreateAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAccountRequestValidationError{}

// Validate checks the field values on CreateAccountReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAccountReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAccountReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAccountReplyMultiError, or nil if none found.
func (m *CreateAccountReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAccountReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccountDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAccountReplyValidationError{
					field:  "AccountDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAccountReplyValidationError{
					field:  "AccountDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccountDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAccountReplyValidationError{
				field:  "AccountDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAccountReplyMultiError(errors)
	}
	return nil
}

// CreateAccountReplyMultiError is an error wrapping multiple validation errors
// returned by CreateAccountReply.ValidateAll() if the designated constraints
// aren't met.
type CreateAccountReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAccountReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAccountReplyMultiError) AllErrors() []error { return m }

// CreateAccountReplyValidationError is the validation error returned by
// CreateAccountReply.Validate if the designated constraints aren't met.
type CreateAccountReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAccountReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAccountReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAccountReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAccountReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAccountReplyValidationError) ErrorName() string {
	return "CreateAccountReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAccountReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAccountReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAccountReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAccountReplyValidationError{}

// Validate checks the field values on UserDetail with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserDetailMultiError, or
// nil if none found.
func (m *UserDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *UserDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserName

	// no validation rules for ClubName

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return UserDetailMultiError(errors)
	}
	return nil
}

// UserDetailMultiError is an error wrapping multiple validation errors
// returned by UserDetail.ValidateAll() if the designated constraints aren't met.
type UserDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserDetailMultiError) AllErrors() []error { return m }

// UserDetailValidationError is the validation error returned by
// UserDetail.Validate if the designated constraints aren't met.
type UserDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserDetailValidationError) ErrorName() string { return "UserDetailValidationError" }

// Error satisfies the builtin error interface
func (e UserDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserDetailValidationError{}

// Validate checks the field values on CreateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserRequestMultiError, or nil if none found.
func (m *CreateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUserName()); l < 1 || l > 50 {
		err := CreateUserRequestValidationError{
			field:  "UserName",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 50 {
		err := CreateUserRequestValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetClubName()); l < 1 || l > 50 {
		err := CreateUserRequestValidationError{
			field:  "ClubName",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateUserRequestMultiError(errors)
	}
	return nil
}

// CreateUserRequestMultiError is an error wrapping multiple validation errors
// returned by CreateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserRequestMultiError) AllErrors() []error { return m }

// CreateUserRequestValidationError is the validation error returned by
// CreateUserRequest.Validate if the designated constraints aren't met.
type CreateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserRequestValidationError) ErrorName() string {
	return "CreateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserRequestValidationError{}

// Validate checks the field values on CreateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserReplyMultiError, or nil if none found.
func (m *CreateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUserDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "UserDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "UserDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserReplyValidationError{
				field:  "UserDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateUserReplyMultiError(errors)
	}
	return nil
}

// CreateUserReplyMultiError is an error wrapping multiple validation errors
// returned by CreateUserReply.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReplyMultiError) AllErrors() []error { return m }

// CreateUserReplyValidationError is the validation error returned by
// CreateUserReply.Validate if the designated constraints aren't met.
type CreateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReplyValidationError) ErrorName() string { return "CreateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReplyValidationError{}

// Validate checks the field values on BanUserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BanUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BanUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BanUserRequestMultiError,
// or nil if none found.
func (m *BanUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BanUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := BanUserRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BanUserRequestMultiError(errors)
	}
	return nil
}

// BanUserRequestMultiError is an error wrapping multiple validation errors
// returned by BanUserRequest.ValidateAll() if the designated constraints
// aren't met.
type BanUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BanUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BanUserRequestMultiError) AllErrors() []error { return m }

// BanUserRequestValidationError is the validation error returned by
// BanUserRequest.Validate if the designated constraints aren't met.
type BanUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BanUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BanUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BanUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BanUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BanUserRequestValidationError) ErrorName() string { return "BanUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e BanUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBanUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BanUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BanUserRequestValidationError{}

// Validate checks the field values on BanUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BanUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BanUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BanUserReplyMultiError, or
// nil if none found.
func (m *BanUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BanUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Res

	if len(errors) > 0 {
		return BanUserReplyMultiError(errors)
	}
	return nil
}

// BanUserReplyMultiError is an error wrapping multiple validation errors
// returned by BanUserReply.ValidateAll() if the designated constraints aren't met.
type BanUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BanUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BanUserReplyMultiError) AllErrors() []error { return m }

// BanUserReplyValidationError is the validation error returned by
// BanUserReply.Validate if the designated constraints aren't met.
type BanUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BanUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BanUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BanUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BanUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BanUserReplyValidationError) ErrorName() string { return "BanUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e BanUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBanUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BanUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BanUserReplyValidationError{}

// Validate checks the field values on UpdateUserNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserNameRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserNameRequestMultiError, or nil if none found.
func (m *UpdateUserNameRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserNameRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateUserNameRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NewUserName

	if len(errors) > 0 {
		return UpdateUserNameRequestMultiError(errors)
	}
	return nil
}

// UpdateUserNameRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateUserNameRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserNameRequestMultiError) AllErrors() []error { return m }

// UpdateUserNameRequestValidationError is the validation error returned by
// UpdateUserNameRequest.Validate if the designated constraints aren't met.
type UpdateUserNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserNameRequestValidationError) ErrorName() string {
	return "UpdateUserNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserNameRequestValidationError{}

// Validate checks the field values on UpdateUserNameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserNameReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserNameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserNameReplyMultiError, or nil if none found.
func (m *UpdateUserNameReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserNameReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Res

	if len(errors) > 0 {
		return UpdateUserNameReplyMultiError(errors)
	}
	return nil
}

// UpdateUserNameReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateUserNameReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserNameReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserNameReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserNameReplyMultiError) AllErrors() []error { return m }

// UpdateUserNameReplyValidationError is the validation error returned by
// UpdateUserNameReply.Validate if the designated constraints aren't met.
type UpdateUserNameReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserNameReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserNameReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserNameReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserNameReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserNameReplyValidationError) ErrorName() string {
	return "UpdateUserNameReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserNameReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserNameReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserNameReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserNameReplyValidationError{}

// Validate checks the field values on UpdateUserPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserPasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserPasswordRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserPasswordRequestMultiError, or nil if none found.
func (m *UpdateUserPasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserPasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateUserPasswordRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOldUserPassword()); l < 6 || l > 50 {
		err := UpdateUserPasswordRequestValidationError{
			field:  "OldUserPassword",
			reason: "value length must be between 6 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNewUserPassword()); l < 6 || l > 50 {
		err := UpdateUserPasswordRequestValidationError{
			field:  "NewUserPassword",
			reason: "value length must be between 6 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateUserPasswordRequestMultiError(errors)
	}
	return nil
}

// UpdateUserPasswordRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateUserPasswordRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateUserPasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserPasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserPasswordRequestMultiError) AllErrors() []error { return m }

// UpdateUserPasswordRequestValidationError is the validation error returned by
// UpdateUserPasswordRequest.Validate if the designated constraints aren't met.
type UpdateUserPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserPasswordRequestValidationError) ErrorName() string {
	return "UpdateUserPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserPasswordRequestValidationError{}

// Validate checks the field values on UpdateUserPasswordReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserPasswordReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserPasswordReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserPasswordReplyMultiError, or nil if none found.
func (m *UpdateUserPasswordReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserPasswordReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Res

	if len(errors) > 0 {
		return UpdateUserPasswordReplyMultiError(errors)
	}
	return nil
}

// UpdateUserPasswordReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateUserPasswordReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserPasswordReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserPasswordReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserPasswordReplyMultiError) AllErrors() []error { return m }

// UpdateUserPasswordReplyValidationError is the validation error returned by
// UpdateUserPasswordReply.Validate if the designated constraints aren't met.
type UpdateUserPasswordReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserPasswordReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserPasswordReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserPasswordReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserPasswordReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserPasswordReplyValidationError) ErrorName() string {
	return "UpdateUserPasswordReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserPasswordReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserPasswordReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserPasswordReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserPasswordReplyValidationError{}

// Validate checks the field values on GetUserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserRequestMultiError,
// or nil if none found.
func (m *GetUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetUserRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserRequestMultiError(errors)
	}
	return nil
}

// GetUserRequestMultiError is an error wrapping multiple validation errors
// returned by GetUserRequest.ValidateAll() if the designated constraints
// aren't met.
type GetUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserRequestMultiError) AllErrors() []error { return m }

// GetUserRequestValidationError is the validation error returned by
// GetUserRequest.Validate if the designated constraints aren't met.
type GetUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserRequestValidationError) ErrorName() string { return "GetUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserRequestValidationError{}

// Validate checks the field values on GetUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserReplyMultiError, or
// nil if none found.
func (m *GetUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUserDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserReplyValidationError{
				field:  "UserDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserReplyMultiError(errors)
	}
	return nil
}

// GetUserReplyMultiError is an error wrapping multiple validation errors
// returned by GetUserReply.ValidateAll() if the designated constraints aren't met.
type GetUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserReplyMultiError) AllErrors() []error { return m }

// GetUserReplyValidationError is the validation error returned by
// GetUserReply.Validate if the designated constraints aren't met.
type GetUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserReplyValidationError) ErrorName() string { return "GetUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserReplyValidationError{}

// Validate checks the field values on ListUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRequestMultiError, or nil if none found.
func (m *ListUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListUserRequestMultiError(errors)
	}
	return nil
}

// ListUserRequestMultiError is an error wrapping multiple validation errors
// returned by ListUserRequest.ValidateAll() if the designated constraints
// aren't met.
type ListUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRequestMultiError) AllErrors() []error { return m }

// ListUserRequestValidationError is the validation error returned by
// ListUserRequest.Validate if the designated constraints aren't met.
type ListUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRequestValidationError) ErrorName() string { return "ListUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRequestValidationError{}

// Validate checks the field values on ListUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListUserReplyMultiError, or
// nil if none found.
func (m *ListUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserDetails() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("UserDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("UserDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserReplyValidationError{
					field:  fmt.Sprintf("UserDetails[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUserReplyMultiError(errors)
	}
	return nil
}

// ListUserReplyMultiError is an error wrapping multiple validation errors
// returned by ListUserReply.ValidateAll() if the designated constraints
// aren't met.
type ListUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserReplyMultiError) AllErrors() []error { return m }

// ListUserReplyValidationError is the validation error returned by
// ListUserReply.Validate if the designated constraints aren't met.
type ListUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserReplyValidationError) ErrorName() string { return "ListUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserReplyValidationError{}

// Validate checks the field values on UserLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLoginRequestMultiError, or nil if none found.
func (m *UserLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUserName()); l < 1 || l > 50 {
		err := UserLoginRequestValidationError{
			field:  "UserName",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 50 {
		err := UserLoginRequestValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserLoginRequestMultiError(errors)
	}
	return nil
}

// UserLoginRequestMultiError is an error wrapping multiple validation errors
// returned by UserLoginRequest.ValidateAll() if the designated constraints
// aren't met.
type UserLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLoginRequestMultiError) AllErrors() []error { return m }

// UserLoginRequestValidationError is the validation error returned by
// UserLoginRequest.Validate if the designated constraints aren't met.
type UserLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLoginRequestValidationError) ErrorName() string { return "UserLoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e UserLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLoginRequestValidationError{}

// Validate checks the field values on UserLoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserLoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLoginReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserLoginReplyMultiError,
// or nil if none found.
func (m *UserLoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Res

	if all {
		switch v := interface{}(m.GetUserDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserLoginReplyValidationError{
					field:  "UserDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserLoginReplyValidationError{
					field:  "UserDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserLoginReplyValidationError{
				field:  "UserDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserLoginReplyMultiError(errors)
	}
	return nil
}

// UserLoginReplyMultiError is an error wrapping multiple validation errors
// returned by UserLoginReply.ValidateAll() if the designated constraints
// aren't met.
type UserLoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLoginReplyMultiError) AllErrors() []error { return m }

// UserLoginReplyValidationError is the validation error returned by
// UserLoginReply.Validate if the designated constraints aren't met.
type UserLoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLoginReplyValidationError) ErrorName() string { return "UserLoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e UserLoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLoginReplyValidationError{}

// Validate checks the field values on UserLogoutRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLogoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLogoutRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLogoutRequestMultiError, or nil if none found.
func (m *UserLogoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLogoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UserLogoutRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserLogoutRequestMultiError(errors)
	}
	return nil
}

// UserLogoutRequestMultiError is an error wrapping multiple validation errors
// returned by UserLogoutRequest.ValidateAll() if the designated constraints
// aren't met.
type UserLogoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLogoutRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLogoutRequestMultiError) AllErrors() []error { return m }

// UserLogoutRequestValidationError is the validation error returned by
// UserLogoutRequest.Validate if the designated constraints aren't met.
type UserLogoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLogoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLogoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLogoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLogoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLogoutRequestValidationError) ErrorName() string {
	return "UserLogoutRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserLogoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLogoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLogoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLogoutRequestValidationError{}

// Validate checks the field values on UserLogoutReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLogoutReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLogoutReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLogoutReplyMultiError, or nil if none found.
func (m *UserLogoutReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLogoutReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Res

	if len(errors) > 0 {
		return UserLogoutReplyMultiError(errors)
	}
	return nil
}

// UserLogoutReplyMultiError is an error wrapping multiple validation errors
// returned by UserLogoutReply.ValidateAll() if the designated constraints
// aren't met.
type UserLogoutReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLogoutReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLogoutReplyMultiError) AllErrors() []error { return m }

// UserLogoutReplyValidationError is the validation error returned by
// UserLogoutReply.Validate if the designated constraints aren't met.
type UserLogoutReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLogoutReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLogoutReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLogoutReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLogoutReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLogoutReplyValidationError) ErrorName() string { return "UserLogoutReplyValidationError" }

// Error satisfies the builtin error interface
func (e UserLogoutReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLogoutReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLogoutReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLogoutReplyValidationError{}
